Renesas RZN1 Clock Binding Documentation

This binding uses the common clock binding[1] with extensions.

[1] Documentation/devicetree/bindings/clock/clock-bindings.txt

1] Rationale
------------
The Renesas RZN1 device tree clock structure is mostly autogenerated from the
specification document. The data was extracted from a variety of such
documents, with the goal of being able to follow these documents and
re-generate these files if/when the specification evolves.

A number of clock drivers are in place to handle the various features of the
clock tree:
	+ renesas,rzn1-clock is the 'container' driver, it's only real job is to
	  map the SYSCTRL io block that will be used by all the other
	  drivers.
	+ renesas,rzn1-clock-gate is a mapping that creates a generic clk-gate
	  using the information extracted from the clock gate table (see 3]).
	+ renesas,rzn1-clock-divider is a driver that is derived from the
	  generic clk-divider linux driver, but has been simplified in some
	  ways, and the primary feature it needed was to handle the
	  SYSCTRL 'BUSY' flag that is paired with each divider in the SYSCTRL
	  block.
	+ renesas,rzn1-clock-bitselect is a clock privider that allows one bit
	  to change the clock source of multiple sub clocks.
	+ renesas,rzn1-clock-dualgate is a clock provider that is always a
	  subclock of a bitselect block, as these clock source have different
	  clock gates depending on which source is selected (!).
	+ renesas,rzn1-clock-group is a clock provider that allows multiple
	  clocks to be claimed and enabled while masquerading as a single
	  source.

2] Clock Container
------------------
The renesas,rzn1-clocks driver exists only to be the first one that is loaded,
to ensure that the SYSCTRL registers are mapped for all the other sub-drivers
to use.
It also provides a /sys/kernel/rzn1/ interface with the following files:
	+ /sys/kernel/rzn1/clk_set_rate
	  This file allows userland to change the clock rate of anything that
	  will allow it. It was mainly made to test the clock infrastructure,
	  however it could be used for other purposes

3] Clock Gates
--------------
The first important piece of data is the clock gates; all of these were
extracted automatically from the SYSCTRL block documentation. Each of the gates
was extracted, it's named derived from the register it is in, and an optional
reset and 'slave ready' bit was also extracted at the same time.

Each of these gates were given a number, and are all listed in the
	./include/dt-bindings/clock/rzn1-clocks.h file.

For a given rzn1-clocks.h definition, for example:

	#define RZN1_CLK_ADC			24

You will find in rzn1-clkctrl-tables.h in the table that allow reverse mapping
that arbitrary number to a set of register and bits:

	[RZN1_PCLK_ADC] =
		_CLK("pclk_adc", _BIT(13, 15), _BIT(13, 16), _BIT(13, 17)),

The _BIT() macro has the register number (as a 32 bit word) in the SYSCTRL
block, so here '13' means RZN1_SYSCTRL_REG_PWRCTRL_BASICS_0 as defined in
the file:

	./include/dt-bindings/soc/rzn1-sysctrl.h

The Device Mapping is otherwise very simple:
	clk_adc: clk_adc {
		#clock-cells = <0>;
		compatible = "renesas,rzn1-clock-gate";
		reg = <RZN1_CLK_ADC>;
		clocks = <&div_adc>;
	};
The <reg> property specifies the clock number, that is all that is needed, the
driver will map that back to a register/bit pair, and create a clk_gate with
it.


4] Clock Divider
----------------
Each divider has a standard format register in SYSCTRL, containing a few
bits for the divider and a BUSY bit, as bit 31.
The mapping is therefore pretty easy too:
	div_adc: div_adc {
		#clock-cells = <0>;
		compatible = "renesas,rzn1-clock-divider";
		renesas,rzn1-bit-mask = <0xff>;
		renesas,rzn1-div-min = <50>;
		renesas,rzn1-div-max = <250>;
		reg = <RZN1_SYSCTRL_REG_PWRCTRL_BASICS_ADCDIV>;
		clocks = <&clkout>;
	};
The <renesas,rzn1-bit-mask> specifies the bits that needs to be set in the <reg>
register. The <reg> register uses a define from the file:
	./include/dt-bindings/soc/rzn1-sysctrl.h
The <renesas,rzn1-div-min> and <renesas,rzn1-div-max> are the minimum and
maximum values for this divider, inclusive.

Some of the clock dividers are not linear, you can't use every divider values
between min and max, therefore there is an extra property that that specifies
the set of valid values:
	rtos_mdc: hw_rtos_mdc: hw_rtos_mdc {
		#clock-cells = <0>;
		compatible = "renesas,rzn1-clock-divider";
		renesas,rzn1-bit-mask = <0x3ff>;
		renesas,rzn1-div-min = <80>;
		renesas,rzn1-div-max = <640>;
		reg = <RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_MDCDIV>;
		renesas,rzn1-div-table = <80 160 320 640>;
		clocks = <&clk_ref_sync>;
	};
Only the values specified in renesas,rzn1-div-table will be used in that
register, and the frequency requested will be adjusted to the value that is
nearest the target value using the corresponding divider value.

5] Clock Bit-Select
-------------------
The renesas,rzn1-clock-bitselect driver exists only to support the 2 groups of
uarts on the machine. All the uarts can have 2 distinctive clock sources, but
not independently of each others. One bit will change the clock source of all
the uarts in that group.
To make things more complicated, there are 2 clock gates per uart, one for
each of the potential clock source.
It sort of looks like this:

    Clock Source 1 -----   bit    /--- Gate 1 Uart 0 --\
                        \ +---+  /  |- Gate 1 Uart 1    \    +------+
                         -| 0 |-/   |- Gate 1 Uart 2     \---| dual |-- Uart 0
                        /-| 1 |-\                        /---| gate |    Clock
                       /  +---+  \---- Gate 2 Uart 0 ---/    +------+
    Clock Source 2 ----   select    |- Gate 2 Uart 1
                                    |- Gate 2 Uart 2           ...

So the purpose of the bit-select and dualgate clocks are to make it appear that
there is a single gate to turn on/off for each uart, and the driver will know
which gate to activate/deactivate depending on the bit-select current status.
Likewise, when the bit-select changes, all the sub clocks dual gate will turn
off the previous clock source gate, and will turn on the new gate.

The instantiation of a clock-bitselect goes like this:
	 uart_group_012: uart_group_012 {
		...

		compatible = "renesas,rzn1-clock-bitselect";
		/* Bit 24 is UARTCLKSEL */
		reg = <RZN1_SYSCTRL_REG_PWRCTRL_BASICS_0>;
		renesas,rzn1-sel-bit = <30>;

		/* If that bit is zero, use first parent, else,
		 * use second parent */
		clocks = <&div_uart>, <&clk_48>;

		/* First group are gates for when selector bit
		 * is zero, second group is the gates to use when
		 * bit is 'one' */
		renesas,rzn1-gates =
		      <RZN1_SCLK_UART0 RZN1_SCLK_UART1
			RZN1_SCLK_UART2>,
		      <RZN1_SCLK_USB_UART0 RZN1_SCLK_USB_UART1
			RZN1_SCLK_USB_UART2>;
		...
	};
The <reg> property specifies the name of the SYSCTRL register where the bit is
defined, and the renesas,rzn1-sel-bit specified which bit it is.
The renesas,rzn1-gates specifies two groups of 'gates'; the first group is the
gates that are to be used when the bit is zero, the second group for went the
bit is 1.

Next come the sub-clock instantiation, the renesas,rzn1-clock-dualgate are
required to be instantiated in the renesas,rzn1-clock-bitselect block.
		gsclk_uart0: gsclk_uart0 {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-dualgate";
			clocks = <&uart_group_012>;
			reg = <0>;
		 };
The 'clocks' property links that clock back to the bitselect group, and the
'reg' property is the index of the gate to use in the renesas,rzn1-gates
property.

6] Clock Grouping
-----------------
There are a lot of IP blocks that rely on having multiple clocks enabled,
even something as simple as a uart requires a SCLK and a PCLK, however, most
linux driver will not enable clocks others than the ones they explicitly
require.
Therefore, a clock driver 'group' was created as renesas,rzn1-clock-group that
allows to specify one single clock per driver, while still preparing and
claiming other 'associated' clocks.
For example:
		 sclk_uart0_grp: sclk_uart0_grp {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-group";
			clocks = <&gsclk_uart0 &pclk_uart0>;
		 };
This will group gsclk_uart0 pclk_uart0 together. The driver will transparently
appear as gsclk_uart0, but will also enable and disable pclk_uart0 along with
the sclk.
This grouping is prevent having to patch multiple linux drivers to force
enable multiple clocks.

7] Clock tree inspection & tweak
--------------------------------
The clock tree can be monitored using debugfs (assuming your kernel has debugfs
compiled in).
# mount -t debugfs / /sys/kernel/debug/
# cd /sys/kernel/debug/
# cat clk/clk_summary
You can then also change the clock rates, for clocks nodes that can:
# echo div_ca7 250000000 >/sys/kernel/rzn1/clk_set_rate
