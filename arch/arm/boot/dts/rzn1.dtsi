/*
 * Device Tree Source for the Renesas RZ/N1 SoC
 *
 * Copyright (C) 2016 Renesas Electronics Europe Ltd
 *
 * This file is licensed under the terms of the GNU General Public License
 * version 2.  This program is licensed "as is" without any warranty of any
 * kind, whether express or implied.
 */

#include <dt-bindings/interrupt-controller/arm-gic.h>
#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/interrupt-controller/rzn1-irq.h>
#include <dt-bindings/soc/rzn1-memory-map.h>
#include <dt-bindings/soc/rzn1-sysctrl.h>
#include <dt-bindings/pinctrl/pinctrl-rzn1.h>
#include <dt-bindings/clock/rzn1-clocks.h>

#include "skeleton.dtsi"

/ {
	compatible = "renesas,rzn1";
	interrupt-parent = <&gic>;
	#address-cells = <1>;
	#size-cells = <1>;

	chosen {
		/* These nodes are specific to the rzn1, and are CAN by the
		 * bootloader. They are optional
		   rzn1,bootaddr = <0xxxxxxxxx>  -- this property is set
		        by the bootloader when it starts in NONSEC mode, this
		        property will contain the address that the second CA7
		        core is 'parked' at, and where it is looking for the
		        boot address code the kernel will pass to it to start it.
		        This property should not be set manually.
		   rzn1,h2mode   -- this bool property, if present, will force
		        the kernel to configure the USB subsystem in 'host' mode,
		        this mode will prevent the usbf 'device' driver to start.
		        This property can be set by the bootloader in case there
		        is a GPIO for this configutation, otherwise, it can also
		        be set manually in the device tree to force a config.
		 */
	};
	cpus {
		#address-cells = <1>;
		#size-cells = <0>;
		clocks = <&clk_a7mp>;

		cpu@0 {
			device_type = "cpu";
			compatible = "arm,cortex-a7";
			reg = <0>;
		};
		cpu@1 {
			device_type = "cpu";
			compatible = "arm,cortex-a7";
			reg = <1>;
		};
	};
	aliases {
		serial0 = &uart0;
		pinctrl = &pinctrl;
		clocks = &clocks;
		ethernet0 = &gmac0;
		ethernet1 = &gmac1;
		spi0 = &qspi0;
		i2c0 = &i2c0;
		i2c1 = &i2c1;
	};
	clocks: clocks@0 {
		compatible = "renesas,rzn1-clock";
		reg = <RZN1_SYSTEM_CTRL_BASE RZN1_SYSTEM_CTRL_SIZE>;
		#address-cells = <1>;
		#size-cells = <0>;
		status = "okay";

		/* Most of the clock definition is declared in the
		 * autogenerated file rzn1-clocks.dtsi
		 * Here we find the 'exceptions' - mostly grouping clocks
		 * together to attach to drivers */

		/* Needed for pinctrl access !*/
		hclk_pinconfig { renesas,no-disable; };

		clk_ddr_grp: clk_ddr_grp {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-group";
			clocks = <&clk_ddrc &hclk_ddrc>;
		};
		all_usbf: all_usbf {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-group";
			clocks = <&hclk_usbf &hclk_usbpm &clk_48_pg_f>;
		};
		/* USB Host Needs the USB Device clocks(!) since the EPCTR
		 * register is in the USBF register map, and that register is
		 * needed to start the PLL */
		all_usbh: all_usbh {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-group";
			clocks = <&hclk_usbh &hclk_usbpm &clk_pci_usb &all_usbf>;
		};
		all_lcd: all_lcd {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-group";
			clocks = <&hclk_lcd &hclk_pg_i>;
		};
		clk_switch_all: clk_switch_all {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-group";
			clocks = <&hclk_switch &clk_switch>;
		};
		clk_rgmii_conv_all: clk_rgmii_conv_all {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-group";
			clocks = <&clk_mii_ref &clk_rmii_ref &clk_rgmii_ref &hclk_switch_rg>;
		};
		uart_group_34567: uart_group_34567 {
			#clock-cells = <0>;
			#address-cells = <1>;
			#size-cells = <0>;

			compatible = "renesas,rzn1-clock-bitselect";
			/* Bit 24 is UARTCLKSEL */
			reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2>;
			renesas,rzn1-sel-bit = <24>;

			/* If that bit is zero, use first parent, else,
			 * use second parent */
			clocks = <&div_p2_pg>, <&clk_48>;

			/* First group are gates for when selector bit
			 * is zero, second group is the gates to use when
			 * bit is 'one' */
			renesas,rzn1-gates =
			      <RZN1_CLK_UART3_ID RZN1_CLK_UART4_ID
				RZN1_CLK_UART5_ID RZN1_CLK_UART6_ID
				RZN1_CLK_UART7_ID>,
			      <RZN1_CLK_USBUART3_ID RZN1_CLK_USBUART4_ID
				RZN1_CLK_USBUART5_ID RZN1_CLK_USBUART6_ID
				RZN1_CLK_USBUART7_ID>;

			gsclk_uart3: gsclk_uart3@0 {
				#clock-cells = <0>;
				compatible = "renesas,rzn1-clock-dualgate";
				clocks = <&uart_group_34567>;
				reg = <0>;
			 };
			gsclk_uart4: gsclk_uart4@1 {
				#clock-cells = <0>;
				compatible = "renesas,rzn1-clock-dualgate";
				clocks = <&uart_group_34567>;
				reg = <1>;
			 };
			gsclk_uart5: gsclk_uart5@2 {
				#clock-cells = <0>;
				compatible = "renesas,rzn1-clock-dualgate";
				clocks = <&uart_group_34567>;
				reg = <2>;
			 };
			gsclk_uart6: gsclk_uart6@3 {
				#clock-cells = <0>;
				compatible = "renesas,rzn1-clock-dualgate";
				clocks = <&uart_group_34567>;
				reg = <3>;
			 };
			gsclk_uart7: gsclk_uart7@4 {
				#clock-cells = <0>;
				compatible = "renesas,rzn1-clock-dualgate";
				clocks = <&uart_group_34567>;
				reg = <4>;
			 };
		 };
		 uart_group_012: uart_group_012@RZN1_SYSCTRL_REG_PWRCTRL_PG0_0 {
			#clock-cells = <0>;
			#address-cells = <1>;
			#size-cells = <0>;

			compatible = "renesas,rzn1-clock-bitselect";
			/* Bit 24 is UARTCLKSEL */
			reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG0_0>;
			renesas,rzn1-sel-bit = <30>;

			/* If that bit is zero, use first parent, else,
			 * use second parent */
			clocks = <&div_uart>, <&clk_48>;

			/* First group are gates for when selector bit
			 * is zero, second group is the gates to use when
			 * bit is 'one' */
			renesas,rzn1-gates =
			      <RZN1_CLK_UART0_ID RZN1_CLK_UART1_ID
				RZN1_CLK_UART2_ID>,
			      <RZN1_CLK_USBUART0_ID RZN1_CLK_USBUART1_ID
				RZN1_CLK_USBUART2_ID>;
			gsclk_uart0: gsclk_uart0@0 {
				#clock-cells = <0>;
				compatible = "renesas,rzn1-clock-dualgate";
				clocks = <&uart_group_012>;
				reg = <0>;
			 };
			gsclk_uart1: gsclk_uart1@1 {
				#clock-cells = <0>;
				compatible = "renesas,rzn1-clock-dualgate";
				clocks = <&uart_group_012>;
				reg = <1>;
			 };
			gsclk_uart2: gsclk_uart2@2 {
				#clock-cells = <0>;
				compatible = "renesas,rzn1-clock-dualgate";
				clocks = <&uart_group_012>;
				reg = <2>;
			};
		};
		clk_i2c0_grp: clk_i2c0_grp {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-group";
			clocks = <&clk_i2c0 &hclk_i2c0>;
		};
		clk_i2c1_grp: clk_i2c1_grp {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-group";
			clocks = <&clk_i2c1 &hclk_i2c1>;
		};
		clk_spi0_grp: clk_spi0_grp {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-group";
			clocks = <&clk_spi0>, <&hclk_spi0>;
		};
		clk_spi1_grp: clk_spi1_grp {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-group";
			clocks = <&clk_spi1>, <&hclk_spi1>;
		};
		clk_spi2_grp: clk_spi2_grp {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-group";
			clocks = <&clk_spi2>, <&hclk_spi2>;
		};
		clk_spi3_grp: clk_spi3_grp {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-group";
			clocks = <&clk_spi3>, <&hclk_spi3>;
		};
		clk_spi4_grp: clk_spi4_grp {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-group";
			clocks = <&clk_spi4>, <&hclk_spi4>;
		};
		clk_spi5_grp: clk_spi5_grp {
			#clock-cells = <0>;
			compatible = "renesas,rzn1-clock-group";
			clocks = <&clk_spi5>, <&hclk_spi5>;
		};
	};

	arm_timer: timer {
		compatible = "arm,armv7-timer";
		arm,cpu-registers-not-fw-configured;
		interrupts =
			<GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
			<GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
			<GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
			<GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
	};

	gic: interrupt-controller@RZN1_GIC_BASE {
		compatible = "arm,cortex-a7-gic";
		reg = <0x44101000 0x1000>,	/* Distributer */
		      <0x44102000 0x1000>,	/* CPU interface */
		      <0x44104000 0x2000>,	/* Virt interface control */
		      <0x44106000 0x2000>;	/* Virt CPU interface */
		interrupt-controller;
		#interrupt-cells = <3>;
		interrupts =
			<GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(2) |
				IRQ_TYPE_LEVEL_HIGH)>;
	};

	gpioirq: gpioirq@RZN1_SYSTEM_CTRL_BASE {
		compatible = "renesas,rzn1-gpioirq";
		status = "disabled";
		interrupts =
			<GIC_SPI RZN1_IRQ_GPIO_0 IRQ_TYPE_LEVEL_HIGH>,
			<GIC_SPI RZN1_IRQ_GPIO_1 IRQ_TYPE_LEVEL_HIGH>,
			<GIC_SPI RZN1_IRQ_GPIO_2 IRQ_TYPE_LEVEL_HIGH>,
			<GIC_SPI RZN1_IRQ_GPIO_3 IRQ_TYPE_LEVEL_HIGH>,
			<GIC_SPI RZN1_IRQ_GPIO_4 IRQ_TYPE_LEVEL_HIGH>,
			<GIC_SPI RZN1_IRQ_GPIO_5 IRQ_TYPE_LEVEL_HIGH>,
			<GIC_SPI RZN1_IRQ_GPIO_6 IRQ_TYPE_LEVEL_HIGH>,
			<GIC_SPI RZN1_IRQ_GPIO_7 IRQ_TYPE_LEVEL_HIGH>;
		interrupt-controller;
		#interrupt-cells = <1>;
	};

	cm3: cm3@RZN1_SRAM_ID_BASE {
		compatible = "renesas,rzn1-cm3";
		#address-cells = <1>;
		#size-cells = <0>;
		status = "disabled";
		reg = <RZN1_SRAM_ID_BASE RZN1_SRAM_ID_SIZE>;
		/* Optional, load and run a CM3 firmware at boot time */
		/* firmware-name = "cm3-freertos.bin"; */
	};

	bus {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;
		u-boot,dm-pre-reloc;

		memory-controller@RZN1_DDR_BASE {
			compatible = "cadence,ddr-ctrl";
			reg = <RZN1_DDR_BASE RZN1_DDR_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_DDRSUB IRQ_TYPE_LEVEL_HIGH>;
			clocks = <&clk_ddr_grp>;
			status = "okay";
		};
		pinctrl: pinctrl@RZN1_PINCTRL_BASE {
			compatible = "renesas,rzn1-pinctrl";
			reg = <RZN1_PINCTRL_BASE RZN1_PINCTRL_SIZE>,
				<RZN1_PINCTRL_L2_BASE RZN1_PINCTRL_L2_SIZE>;
			#address-cells = <1>;
			#size-cells = <0>;
			status = "okay";
		};
		ipc: mailbox@RZN1_MAILBOX_BASE {
		    compatible = "arm,pl320", "arm,primecell";
		    reg = <RZN1_MAILBOX_BASE RZN1_MAILBOX_SIZE>;
		    interrupts = <GIC_SPI RZN1_IRQ_IPCM_1 IRQ_TYPE_LEVEL_HIGH>;
		    clocks = <&clk_fw>;
		    clock-names = "apb_pclk";
		};
		timer0: timer@RZN1_TIMER0_BASE {
			compatible = "renesas,rzn1-timer";
			reg = <RZN1_TIMER0_BASE RZN1_TIMER0_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_TIMER0_0 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_TIMER0_1 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_TIMER0_2 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_TIMER0_3 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_TIMER0_4 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_TIMER0_5 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_TIMER0_6 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_TIMER0_7 IRQ_TYPE_LEVEL_HIGH>;
			clocks = <&hclk_timer0>;
			status = "disabled";
		};
		timer1: timer@RZN1_TIMER1_BASE {
			compatible = "renesas,rzn1-timer";
			reg = <RZN1_TIMER1_BASE RZN1_TIMER1_SIZE>;
			renesas,timer-number = <1>;
			interrupts = <GIC_SPI RZN1_IRQ_TIMER1_0 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_TIMER1_1 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_TIMER1_2 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_TIMER1_3 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_TIMER1_4 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_TIMER1_5 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_TIMER1_6 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_TIMER1_7 IRQ_TYPE_LEVEL_HIGH>;
			clocks = <&hclk_timer1>;
			status = "disabled";
		};
		uart0: serial@RZN1_UART0_BASE {
			compatible = "snps,dw-apb-uart";
			reg = <RZN1_UART0_BASE RZN1_UART0_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_UART0 IRQ_TYPE_LEVEL_HIGH>;
			reg-shift = <2>;
			reg-io-width = <4>;
			fifo-size = <16>;
			afce-mode;
			clocks = <&gsclk_uart0 &hclk_uart0>;
			clock-names = "baudclk", "apb_pclk";
			status = "disabled";
		};
		uart1: serial@RZN1_UART1_BASE {
			compatible = "snps,dw-apb-uart";
			reg = <RZN1_UART1_BASE RZN1_UART1_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_UART1 IRQ_TYPE_LEVEL_HIGH>;
			reg-shift = <2>;
			reg-io-width = <4>;
			fifo-size = <16>;
			afce-mode;
			clocks = <&gsclk_uart1 &hclk_uart1>;
			clock-names = "baudclk", "apb_pclk";
			status = "disabled";
		};
		uart2: serial@RZN1_UART2_BASE {
			compatible = "snps,dw-apb-uart";
			reg = <RZN1_UART2_BASE RZN1_UART2_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_UART2 IRQ_TYPE_LEVEL_HIGH>;
			reg-shift = <2>;
			reg-io-width = <4>;
			fifo-size = <16>;
			afce-mode;
			clocks = <&gsclk_uart2 &hclk_uart2>;
			clock-names = "baudclk", "apb_pclk";
			status = "disabled";
		};
		uart3: serial@RZN1_UART3_BASE {
			compatible = "snps,dw-apb-uart";
			reg = <RZN1_UART3_BASE RZN1_UART3_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_UART3 IRQ_TYPE_LEVEL_HIGH>;
			reg-shift = <2>;
			reg-io-width = <4>;
			fifo-size = <16>;
			afce-mode;
			clocks = <&gsclk_uart3 &hclk_uart3>;
			clock-names = "baudclk", "apb_pclk";
			status = "disabled";
		};
		uart4: serial@RZN1_UART4_BASE {
			compatible = "snps,dw-apb-uart";
			reg = <RZN1_UART4_BASE RZN1_UART4_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_UART4 IRQ_TYPE_LEVEL_HIGH>;
			reg-shift = <2>;
			reg-io-width = <4>;
			fifo-size = <16>;
			afce-mode;
			clocks = <&gsclk_uart4 &hclk_uart4>;
			clock-names = "baudclk", "apb_pclk";
			status = "disabled";
		};
		uart5: serial@RZN1_UART5_BASE {
			compatible = "snps,dw-apb-uart";
			reg = <RZN1_UART5_BASE RZN1_UART5_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_UART5 IRQ_TYPE_LEVEL_HIGH>;
			reg-shift = <2>;
			reg-io-width = <4>;
			fifo-size = <16>;
			afce-mode;
			clocks = <&gsclk_uart5 &hclk_uart5>;
			clock-names = "baudclk", "apb_pclk";
			status = "disabled";
		};
		uart6: serial@RZN1_UART6_BASE {
			compatible = "snps,dw-apb-uart";
			reg = <RZN1_UART6_BASE RZN1_UART6_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_UART6 IRQ_TYPE_LEVEL_HIGH>;
			reg-shift = <2>;
			reg-io-width = <4>;
			fifo-size = <16>;
			afce-mode;
			clocks = <&gsclk_uart6 &hclk_uart6>;
			clock-names = "baudclk", "apb_pclk";
			status = "disabled";
		};
		uart7: serial@RZN1_UART7_BASE {
			compatible = "snps,dw-apb-uart";
			reg = <RZN1_UART7_BASE RZN1_UART7_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_UART7 IRQ_TYPE_LEVEL_HIGH>;
			reg-shift = <2>;
			reg-io-width = <4>;
			fifo-size = <16>;
			afce-mode;
			clocks = <&gsclk_uart7 &hclk_uart7>;
			clock-names = "baudclk", "apb_pclk";
			status = "disabled";
		};
		i2c0: i2c@RZN1_I2C0_BASE {
			#address-cells = <1>;
			#size-cells = <0>;
			compatible = "snps,designware-i2c";
			reg = <RZN1_I2C0_BASE RZN1_I2C0_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_I2C0 IRQ_TYPE_LEVEL_HIGH>;
			clock-names = "pclk";
			clocks = <&clk_i2c0_grp>;
			clock-frequency = <100000>;
			status = "disabled";
		};
		i2c1: i2c@RZN1_I2C1_BASE {
			#address-cells = <1>;
			#size-cells = <0>;
			compatible = "snps,designware-i2c";
			reg = <RZN1_I2C1_BASE RZN1_I2C1_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_I2C1 IRQ_TYPE_LEVEL_HIGH>;
			clock-names = "pclk";
			clocks = <&clk_i2c1_grp>;
			clock-frequency = <100000>;
			status = "disabled";
		};
		rtc0: rtc@RZN1_RTC_BASE {
			#address-cells = <1>;
			#size-cells = <0>;
			compatible = "renesas,rzn1-rtc";
			reg = <RZN1_RTC_BASE RZN1_RTC_SIZE>;
			clock-names = "axi";
			clocks = <&hclk_rtc>;
			interrupt-names = "alarm", "intr", "1hz";
			interrupts =
				<GIC_SPI RZN1_IRQ_RTCATINTAL IRQ_TYPE_EDGE_RISING>,
				<GIC_SPI RZN1_IRQ_RTCATINTR IRQ_TYPE_EDGE_RISING>,
				<GIC_SPI RZN1_IRQ_RTCATINT1S IRQ_TYPE_EDGE_RISING>;
			status = "disabled";
		};
		gmac0: ethernet@RZN1_GMAC0_BASE {
			compatible = "snps,dwmac-3.72a", "snps,dwmac";
			reg = <RZN1_GMAC0_BASE RZN1_GMAC0_SIZE>;
			interrupt-parent = <&gic>;
			interrupts = <GIC_SPI RZN1_IRQ_SBD0 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_LPI0 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_PMT0 IRQ_TYPE_LEVEL_HIGH>;
			interrupt-names = "macirq", "eth_lpi", "eth_wake_irq";
			clock-names = "stmmaceth";
			clocks = <&hclk_gmac0>;
			status = "disabled";
		};
		gmac1: ethernet@RZN1_GMAC1_BASE {
			compatible = "snps,dwmac-3.72a", "snps,dwmac";
			reg = <RZN1_GMAC1_BASE RZN1_GMAC1_SIZE>;
			interrupt-parent = <&gic>;
			interrupts = <GIC_SPI RZN1_IRQ_SBD1 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_LPI1 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_PMT1 IRQ_TYPE_LEVEL_HIGH>;
			interrupt-names = "macirq", "eth_lpi", "eth_wake_irq";
			clock-names = "stmmaceth";
			clocks = <&hclk_gmac1>;
			status = "disabled";
		};
		switch: ethswitch: eth-switch@RZN1_SWITCH_BASE {
			compatible = "mtip,5pt_switch";
			#address-cells = <1>;
			#size-cells = <0>;
			reg = <RZN1_SWITCH_BASE RZN1_SWITCH_SIZE>;
			clock-names = "fck";
			clocks = <&clk_switch_all>;
			status = "disabled";
		};
		eth_miic: eth-miic@RZN1_SWITCH_CTRL_REG_BASE {
			compatible = "renesas,rzn1-miic";
			#address-cells = <1>;
			#size-cells = <0>;
			reg = <RZN1_SWITCH_CTRL_REG_BASE RZN1_SWITCH_CTRL_REG_SIZE>;
			status = "disabled";
			clocks = <&clk_rgmii_conv_all>;
		};

		dma0: dma-controller@RZN1_DMA0_BASE {
			compatible = "snps,dma-rzn1";
			reg = <RZN1_DMA0_BASE RZN1_DMA0_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_DMA0 IRQ_TYPE_LEVEL_HIGH>;
			clock-names = "hclk";
			clocks = <&hclk_dma0>;
			dma-channels = <8>;
			dma-requests = <16>;
			dma-masters = <1>;
			#dma-cells = <3>;
			block_size = <0xfff>;
			data_width = <3>;
			status = "disabled";
		};
		dma1: dma-controller@RZN1_DMA1_BASE {
			compatible = "snps,dma-rzn1";
			reg = <RZN1_DMA1_BASE RZN1_DMA1_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_DMA1 IRQ_TYPE_LEVEL_HIGH>;
			clock-names = "hclk";
			clocks = <&hclk_dma1>;
			dma-channels = <8>;
			dma-requests = <16>;
			dma-masters = <1>;
			#dma-cells = <3>;
			block_size = <0xfff>;
			data_width = <3>;
			status = "disabled";
		};
		sdio0: sdhci@RZN1_SDIO0_BASE {
			compatible = "arasan,sdhci-8.9a";
			reg = <RZN1_SDIO0_BASE RZN1_SDIO0_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_SDIO0 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_SDIO0_WKUP IRQ_TYPE_LEVEL_HIGH>;
			clock-names = "clk_xin", "clk_ahb";
			clocks = <&clk_sdio0>, <&hclk_sdio0>;
			no-1-8-v;
			status = "disabled";
		};
		sdio1: sdhci@RZN1_SDIO1_BASE {
			compatible = "arasan,sdhci-8.9a";
			reg = <RZN1_SDIO1_BASE RZN1_SDIO1_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_SDIO1 IRQ_TYPE_LEVEL_HIGH>,
				     <GIC_SPI RZN1_IRQ_SDIO1_WKUP IRQ_TYPE_LEVEL_HIGH>;
			clock-names = "clk_xin", "clk_ahb";
			clocks = <&clk_sdio1>, <&hclk_sdio1>;
			no-1-8-v;
			status = "disabled";
		};
		qspi: qspi0: spi@RZN1_QSPI_BASE {
			compatible = "renesas,rzn1-qspi";
			#address-cells = <1>;
			#size-cells = <0>;
			reg = <RZN1_QSPI_BASE RZN1_QSPI_SIZE
				RZN1_V_QSPI_BASE RZN1_V_QSPI_SIZE>;
			reg-names = "qspi", "qspi-mapping";
			interrupts = <GIC_SPI RZN1_IRQ_QSPI0 IRQ_TYPE_LEVEL_HIGH>;
			clocks = <&hclk_qspi0>, <&clk_qspi0>;
			clock-names = "flexway", "pclk";
			status = "disabled";
		};
		nand: nand@RZN1_NAND_BASE {
			compatible = "evatronix,nandflash-ctrl";
			reg = <RZN1_NAND_BASE RZN1_NAND_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_NAND IRQ_TYPE_LEVEL_HIGH>;
			clocks = <&hclk_nand>, <&clk_nand>;
			clock-names = "clka", "clkb";
			#address-cells		= <1>;
			#size-cells		= <1>;
			status = "disabled";
		};
		/*
		 * SPI 0-3 are Master; 4-5 are Slave. 4-16 bits data width
		 * dw_apb-ssi is configured with 16*16 bits FIFO in both
		 * directions.
		 * 4 Chipselects for the master interfaces, 1 for slaves
		 */
		spi0: spi@RZN1_SPI0_BASE {
			compatible = "snps,dw-apb-ssi";
			reg = <RZN1_SPI0_BASE RZN1_SPI0_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_SPI0 IRQ_TYPE_LEVEL_HIGH>;
			clock-names = "pclk";
			clocks = <&clk_spi0_grp>;
			#address-cells = <1>;
			#size-cells = <0>;
			num-cs = <4>;
			status = "disabled";
		};
		spi1: spi@RZN1_SPI1_BASE {
			compatible = "snps,dw-apb-ssi";
			reg = <RZN1_SPI1_BASE RZN1_SPI1_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_SPI1 IRQ_TYPE_LEVEL_HIGH>;
			clock-names = "pclk";
			clocks = <&clk_spi1_grp>;
			#address-cells = <1>;
			#size-cells = <0>;
			num-cs = <4>;
			status = "disabled";
		};
		spi2: spi@RZN1_SPI2_BASE {
			compatible = "snps,dw-apb-ssi";
			reg = <RZN1_SPI2_BASE RZN1_SPI2_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_SPI2 IRQ_TYPE_LEVEL_HIGH>;
			clock-names = "pclk";
			clocks = <&clk_spi2_grp>;
			#address-cells = <1>;
			#size-cells = <0>;
			num-cs = <4>;
			status = "disabled";
		};
		spi3: spi@RZN1_SPI3_BASE {
			compatible = "snps,dw-apb-ssi";
			reg = <RZN1_SPI3_BASE RZN1_SPI3_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_SPI3 IRQ_TYPE_LEVEL_HIGH>;
			clock-names = "pclk";
			clocks = <&clk_spi3_grp>;
			#address-cells = <1>;
			#size-cells = <0>;
			num-cs = <4>;
			status = "disabled";
		};
		spi4: spi@RZN1_SPI4_BASE {
			compatible = "snps,dw-apb-ssi";
			reg = <RZN1_SPI4_BASE RZN1_SPI4_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_SPI4 IRQ_TYPE_LEVEL_HIGH>;
			clock-names = "pclk";
			clocks = <&clk_spi4_grp>;
			#address-cells = <1>;
			#size-cells = <0>;
			num-cs = <1>; /* Slave interface */
			status = "disabled";
		};
		spi5: spi@RZN1_SPI5_BASE {
			compatible = "snps,dw-apb-ssi";
			reg = <RZN1_SPI5_BASE RZN1_SPI5_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_SPI5 IRQ_TYPE_LEVEL_HIGH>;
			clock-names = "pclk";
			clocks = <&clk_spi5_grp>;
			#address-cells = <1>;
			#size-cells = <0>;
			num-cs = <1>; /* Slave interface */
			status = "disabled";
		};
		usbphy: usbphy0: usbphy@0 {
			#phy-cells = <0>;
			compatible = "usb-nop-xceiv";
			status = "disabled";
		};
		usbf: usbf@RZN1_USB_DEV_BASE {
			compatible = "renesas,rzn1-usbf";
			reg = <RZN1_USB_DEV_BASE RZN1_USB_DEV_SIZE>;
			interrupts =
				<GIC_SPI RZN1_IRQ_USBF_EPC IRQ_TYPE_LEVEL_HIGH>,
				<GIC_SPI RZN1_IRQ_USBF IRQ_TYPE_LEVEL_HIGH>;
			clock-names = "axi";
			clocks = <&all_usbf>;

			renesas,sram-size = <5024>; /* 32 bits words */
			/* Allow 4 x 512 byte packets per endpoint to support MTU of 1500.
			Due to protocol overheads, 3 x 512 byte packets is not enough. */
			renesas,sram-conf,g_ether = <4 2 0>;
			renesas,sram-conf,g_mass_storage = <8 8 0 0 0 0>;
			status = "disabled";
		};
		usbh_pci: pci@RZN1_USB_HOST_BASE {
			compatible = "renesas,pci-rzn1";
			device_type = "pci";
			clock-names = "axi";
			clocks = <&all_usbh>;
			reg = <(RZN1_USB_HOST_BASE+0x10000) 0xc00>,
			      <RZN1_USB_HOST_BASE 0x1100>;
			interrupts = <GIC_SPI RZN1_IRQ_USBH_BIND IRQ_TYPE_LEVEL_HIGH>;
			status = "disabled";

			bus-range = <0 0>;
			#address-cells = <3>;
			#size-cells = <1>;
			#interrupt-cells = <1>;
			ranges = <0x02000000 0 RZN1_USB_HOST_BASE RZN1_USB_HOST_BASE 0x00010000>;
			/* Should map all possible DDR as inbound ranges, but
			   the IP only supports a 256MB, 512MB, or 1GB window */
			/* flags, PCI addr (64-bit), CPU addr, PCI size (64-bit) */
			dma-ranges = <0x42000000 0 0x80000000 0x80000000 0 0x40000000>;
			interrupt-map-mask = <0xff00 0 0 0x7>;
			interrupt-map = <0x0000 0 0 1 &gic GIC_SPI RZN1_IRQ_USBH_BIND IRQ_TYPE_LEVEL_HIGH
					 0x0800 0 0 1 &gic GIC_SPI RZN1_IRQ_USBH_BIND IRQ_TYPE_LEVEL_HIGH
					 0x1000 0 0 2 &gic GIC_SPI RZN1_IRQ_USBH_BIND IRQ_TYPE_LEVEL_HIGH>;

			usb@0,1 {
				reg = <0x800 0 0 0>;
				device_type = "pci";
				phys = <&usbphy 0 0>;
				phy-names = "usb";
			};

			usb@0,2 {
				reg = <0x1000 0 0 0>;
				device_type = "pci";
				phys = <&usbphy 0 0>;
				phy-names = "usb";
			};
		};
		reset: reset@RZN1_RESET_BASE {
			reg = <RZN1_RESET_BASE RZN1_RESET_SIZE>;
			clocks = <&hclk_pinconfig>;
		};
		wdtsafe0: wdtsafe0@RZN1_WATCHDOGSAFE0_BASE {
			compatible = "renesas,rzn1-watchdogsafe";
			reg = <RZN1_WATCHDOGSAFE0_BASE RZN1_WATCHDOGSAFE0_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_WATCHDOGSAFE0 IRQ_TYPE_LEVEL_HIGH>;
			clocks = <&hclk_pinconfig>;
			status = "disabled";
		};
		wdtsafe1: wdtsafe1@RZN1_WATCHDOGSAFE1_BASE {
			compatible = "renesas,rzn1-watchdogsafe";
			reg = <RZN1_WATCHDOGSAFE1_BASE RZN1_WATCHDOGSAFE1_SIZE>;
			interrupts = <GIC_SPI RZN1_IRQ_WATCHDOGSAFE1 IRQ_TYPE_LEVEL_HIGH>;
			clocks = <&hclk_pinconfig>;
			status = "disabled";
		};
		/*
		 * The GPIO mapping to the corresponding pins is complicted,
		 * see the hardware documentation for details.
		 */
		gpio0: gpio@RZN1_GPIO0_BASE {
			compatible = "snps,dw-apb-gpio";
			reg = <RZN1_GPIO0_BASE RZN1_GPIO0_SIZE>;
			#address-cells = <1>;
			#size-cells = <0>;
			clocks = <&hclk_gpio0>;
			status = "disabled";

			gpio0a: gpio-controller@0 {
				compatible = "snps,dw-apb-gpio-port";
				bank-name = "gpio0a";
				gpio-controller;
				#gpio-cells = <2>;
				snps,nr-gpios = <32>;
				reg = <0>;

				/*
				 * There are 32 irqs going from this gpio block
				 * to the gpio irq mux block, hence the large
				 * list of interrupts.
				 */
				interrupt-parent = <&gpioirq>;
				interrupts =   < 0  1  2  3  4  5  6  7
						 8  9 10 11 12 13 14 15
						16 17 18 19 20 21 22 23
						24 25 26 27 28 29 30 31 >;
				interrupt-controller;
				#interrupt-cells = <2>;
			};
			gpio0b: gpio-controller@1 {
				compatible = "snps,dw-apb-gpio-port";
				bank-name = "gpio0b";
				gpio-controller;
				#gpio-cells = <2>;
				snps,nr-gpios = <32>;
				reg = <1>;
			};
		};
		gpio1: gpio@RZN1_GPIO1_BASE {
			compatible = "snps,dw-apb-gpio";
			reg = <RZN1_GPIO1_BASE RZN1_GPIO1_SIZE>;
			#address-cells = <1>;
			#size-cells = <0>;
			clocks = <&hclk_gpio1>;
			status = "disabled";

			/* GPIO1a[0..4] corresponds to pins 45..49 */
			/* GPIO1a[5..31] corresponds to pins 71..121 */
			gpio1a: gpio-controller@0 {
				compatible = "snps,dw-apb-gpio-port";
				bank-name = "gpio1a";
				gpio-controller;
				#gpio-cells = <2>;
				snps,nr-gpios = <32>;
				reg = <0>;

				/*
				 * There are 32 irqs going from this gpio block
				 * to the gpio irq mux block, hence the large
				 * list of interrupts.
				 */
				interrupt-parent = <&gpioirq>;
				interrupts =  < 32 33 34 35 36 37 38 39
						40 41 42 43 44 45 46 47
						48 49 50 51 52 53 54 55
						56 57 58 59 60 61 62 63 >;
				interrupt-controller;
				#interrupt-cells = <2>;
			};
			/* GPIO1b[0..1] corresponds to pins 31..32 */
			/* GPIO1b[2..4] corresponds to pins 35..37 */
			/* GPIO1b[5..25] corresponds to pins 50..70 */
			/* GPIO1b[26..31] corresponds to pins 150..155 */
			gpio1b: gpio-controller@1 {
				compatible = "snps,dw-apb-gpio-port";
				bank-name = "gpio1b";
				gpio-controller;
				#gpio-cells = <2>;
				snps,nr-gpios = <32>;
				reg = <1>;
			};
		};
		gpio2: gpio@RZN1_GPIO2_BASE {
			compatible = "snps,dw-apb-gpio";
			reg = <RZN1_GPIO2_BASE RZN1_GPIO2_SIZE>;
			#address-cells = <1>;
			#size-cells = <0>;
			clocks = <&hclk_gpio2>;
			status = "disabled";

			/* GPIO2a[0..27] corresponds to pins 122..149 */
			/* GPIO2a[28..31] corresponds to pins 156..159 */
			gpio2a: gpio-controller@0 {
				compatible = "snps,dw-apb-gpio-port";
				bank-name = "gpio2a";
				gpio-controller;
				#gpio-cells = <2>;
				snps,nr-gpios = <32>;
				reg = <0>;

				/*
				 * There are 32 irqs going from this gpio block
				 * to the gpio irq mux block, hence the large
				 * list of interrupts.
				 */
				interrupt-parent = <&gpioirq>;
				interrupts =  < 64 65 66 67 68 69 70 71
						72 73 74 75 76 77 78 79
						80 81 82 83 84 85 86 87
						88 89 90 91 92 93 94 95 >;
				interrupt-controller;
				#interrupt-cells = <2>;
			};
			/* GPIO2b[0..9] corresponds to pins 160..169 */
			gpio2b: gpio-controller@1 {
				compatible = "snps,dw-apb-gpio-port";
				bank-name = "gpio2b";
				gpio-controller;
				#gpio-cells = <2>;
				snps,nr-gpios = <10>;
				reg = <1>;
			};
		};
		sgpio0: gpio@RZN1_SGPIO0_BASE {
			reg = <RZN1_SGPIO0_BASE RZN1_SGPIO0_SIZE>;
		};
		sgpio1: gpio@RZN1_SGPIO1_BASE {
			reg = <RZN1_SGPIO1_BASE RZN1_SGPIO1_SIZE>;
		};
		can0: can@RZN1_CAN0_BASE {
			compatible = "nxp,sja1000";
			reg = <RZN1_CAN0_BASE RZN1_CAN0_SIZE>;
			reg-io-width = <4>;
			interrupts = <GIC_SPI RZN1_IRQ_CAN0 IRQ_TYPE_LEVEL_HIGH>;
			nxp,no-cdr;
			nxp,no-loopback;
			clocks = <&hclk_can0>;
			status = "disabled";
		};
		can1: can@RZN1_CAN1_BASE {
			compatible = "nxp,sja1000";
			reg = <RZN1_CAN1_BASE RZN1_CAN1_SIZE>;
			reg-io-width = <4>;
			interrupts = <GIC_SPI RZN1_IRQ_CAN1 IRQ_TYPE_LEVEL_HIGH>;
			nxp,no-cdr;
			nxp,no-loopback;
			clocks = <&hclk_can1>;
			status = "disabled";
		};
		fb0: fb@RZN1_LCD_BASE {
			compatible = "digitalblocks,db9000-clcd";
			interrupts = <GIC_SPI RZN1_IRQ_LCD IRQ_TYPE_LEVEL_HIGH>;
			reg = <RZN1_LCD_BASE RZN1_LCD_SIZE>;
			clock-names = "pclk", "ahb";
			clocks = <&clk_slcd>, <&all_lcd>;
			status = "disabled";
		};
		msebi: msebim: memory-controller@RZN1_MSEBI_M0_BASE {
			compatible = "renesas,rzn1-msebi";
			#address-cells = <2>;
			#size-cells = <1>;
			reg = <RZN1_MSEBI_M0_BASE RZN1_MSEBI_M0_SIZE>;
			clocks = <&hclk_msebi_m>;
			interrupts = <GIC_SPI RZN1_IRQ_MSEBIM IRQ_TYPE_LEVEL_HIGH>;
			status = "disabled";
		};

		/* These nodes are placeholders; they are refered to by the
		 * pinmux file, but have no driver just yet, so we create
		 * empty nodes for them until we can flesh it up */
		unknown: s3: dsigma: mii: motor: unknown {
		};
	};

};

#include "rzn1-clocks.dtsi"
